#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import prompts, { PromptObject } from 'prompts';
import { collectTemplates } from './templates';
import { ProjectType, SectionToggle, TemplateFile } from './templates/types';

function banner(): void {
  console.log('');
  console.log('üîß DevDocs Init ‚Äì Project Documentation Scaffolder');
  console.log('');
}

function onCancel(): never {
  console.log('\n‚ö†Ô∏è  Aborted. No changes were made.');
  process.exit(1);
}

function ensureDir(dir: string): void {
  fs.mkdirSync(dir, { recursive: true });
}

function applyPlaceholders(content: string, replacements: Record<string, string>): string {
  return content.replace(/{{(.*?)}}/g, (_, key: string) => {
    const trimmed = key.trim();
    return Object.prototype.hasOwnProperty.call(replacements, trimmed)
      ? replacements[trimmed]
      : `{{${trimmed}}}`;
  });
}

function writeFileWithBackup(targetPath: string, content: string, summary: string[]): void {
  ensureDir(path.dirname(targetPath));

  if (fs.existsSync(targetPath)) {
    const backupPath = `${targetPath}.bak`;
    fs.copyFileSync(targetPath, backupPath);
    summary.push(`Existing file found. Backed up to ${path.relative(process.cwd(), backupPath)}`);
  }

  fs.writeFileSync(targetPath, content, 'utf8');
  summary.push(`Created ${path.relative(process.cwd(), targetPath)}`);
}

function buildIndexContent(projectName: string, links: Partial<Record<keyof SectionToggle, string>>): string {
  const items: string[] = [];
  const orderedSections: Array<keyof SectionToggle> = [
    'product',
    'requirements',
    'architecture',
    'adr',
    'qa',
    'ops',
    'process'
  ];

  orderedSections.forEach((section) => {
    if (links[section]) {
      const labelMap: Record<keyof SectionToggle, string> = {
        product: 'Product',
        requirements: 'Requirements',
        architecture: 'Architecture',
        adr: 'Architecture Decisions',
        qa: 'QA & Testing',
        ops: 'Operations',
        process: 'Process & Ways of Working'
      };
      items.push(`- [${labelMap[section]}](${links[section]})`);
    }
  });

  return `# Project Docs ‚Äì {{PROJECT_NAME}}

Generated by devdocs-init. Replace placeholders like {{PROJECT_NAME}} before sharing.

${items.join('\n')}
`;
}

async function promptBaseQuestions(defaultName: string): Promise<{
  projectName: string;
  projectType: ProjectType;
  toggles: SectionToggle;
}> {
  const questions: PromptObject[] = [
    {
      type: 'text',
      name: 'projectName',
      message: 'Project name',
      initial: defaultName
    },
    {
      type: 'select',
      name: 'projectType',
      message: 'Project type',
      choices: [
        { title: 'Personal / Portfolio', value: 'personal' },
        { title: 'College / School', value: 'college' },
        { title: 'Freelance / Client / Industry project', value: 'freelance' }
      ],
      initial: 0
    },
    { type: 'toggle', name: 'product', message: 'Include Product docs?', active: 'yes', inactive: 'no', initial: true },
    { type: 'toggle', name: 'requirements', message: 'Include Requirements docs?', active: 'yes', inactive: 'no', initial: true },
    { type: 'toggle', name: 'architecture', message: 'Include Architecture docs?', active: 'yes', inactive: 'no', initial: true },
    { type: 'toggle', name: 'adr', message: 'Include ADR (Architecture Decision Records)?', active: 'yes', inactive: 'no', initial: true },
    { type: 'toggle', name: 'qa', message: 'Include QA / Test docs?', active: 'yes', inactive: 'no', initial: true },
    { type: 'toggle', name: 'ops', message: 'Include Ops / DevOps docs?', active: 'yes', inactive: 'no', initial: true },
    { type: 'toggle', name: 'process', message: 'Include Process docs?', active: 'yes', inactive: 'no', initial: true }
  ];

  const response = await prompts(questions, { onCancel });

  const toggles: SectionToggle = {
    product: response.product,
    requirements: response.requirements,
    architecture: response.architecture,
    adr: response.adr,
    qa: response.qa,
    ops: response.ops,
    process: response.process
  };

  return { projectName: response.projectName, projectType: response.projectType, toggles };
}

async function promptProjectSpecific(projectType: ProjectType): Promise<Record<string, string>> {
  if (projectType === 'personal') {
    const answers = await prompts(
      [
        { type: 'text', name: 'TECH_STACK', message: 'Tech stack (optional)', initial: 'TypeScript, Node.js' },
        { type: 'text', name: 'AUTHOR_NAME', message: 'Your name (optional)' }
      ],
      { onCancel }
    );
    return answers;
  }

  if (projectType === 'college') {
    const answers = await prompts(
      [
        { type: 'text', name: 'COURSE_NAME', message: 'Course name (optional)' },
        { type: 'text', name: 'COURSE_CODE', message: 'Course code (optional)' },
        { type: 'text', name: 'INSTRUCTOR_NAME', message: 'Instructor name (optional)' },
        { type: 'text', name: 'TEAM_MEMBERS', message: 'Team members (optional)' }
      ],
      { onCancel }
    );
    return answers;
  }

  const answers = await prompts(
    [
      { type: 'text', name: 'CLIENT_NAME', message: 'Client contact name (optional)' },
      { type: 'text', name: 'CLIENT_COMPANY', message: 'Client company (optional)' },
      { type: 'text', name: 'PROJECT_START_DATE', message: 'Project start date (optional)' },
      { type: 'text', name: 'EXPECTED_LAUNCH_DATE', message: 'Expected launch date (optional)' }
    ],
    { onCancel }
  );
  return answers;
}

function groupLandingLinks(templates: TemplateFile[]): Partial<Record<keyof SectionToggle, string>> {
  const links: Partial<Record<keyof SectionToggle, string>> = {};

  templates.forEach((template) => {
    const section = template.path.split('/')[0] as keyof SectionToggle;
    if (!links[section]) {
      links[section] = `./${template.path}`;
    }
  });

  return links;
}

async function main(): Promise<void> {
  banner();
  const cwdName = path.basename(process.cwd());
  const baseAnswers = await promptBaseQuestions(cwdName);
  const placeholderAnswers = await promptProjectSpecific(baseAnswers.projectType);

  const replacements: Record<string, string> = {
    PROJECT_NAME: baseAnswers.projectName,
    ...placeholderAnswers
  };

  const docsRoot = path.join(process.cwd(), 'docs');
  ensureDir(docsRoot);

  const templates = collectTemplates(baseAnswers.projectType, baseAnswers.toggles);
  const links = groupLandingLinks(templates);
  const summary: string[] = [];

  templates.forEach((template) => {
    const targetPath = path.join(docsRoot, template.path);
    const content = applyPlaceholders(template.content, replacements);
    writeFileWithBackup(targetPath, content, summary);
  });

  const indexContent = applyPlaceholders(buildIndexContent(baseAnswers.projectName, links), replacements);
  writeFileWithBackup(path.join(docsRoot, 'index.md'), indexContent, summary);

  console.log('\nSummary:');
  summary.forEach((item) => console.log(`‚Ä¢ ${item}`));
  console.log('\n‚úÖ Done! Start by editing docs/index.md and the section files you selected.');
}

main().catch((error) => {
  console.error('Unexpected error while scaffolding docs:', error);
  process.exit(1);
});
